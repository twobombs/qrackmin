# -*- coding: utf-8 -*-
# Ising model Trotterization as interpreted by (OpenAI GPT) Elara
# Allows setting QRACK_QTENSORNETWORK_THRESHOLD_QB within the script.
# original code generated by Dan Strano https://github.com/vm6502q/pyqrack-examples/blob/main/ising/ising_qbdd.py
# modified for benchmark loop use in ThereminQ by Gemini25

import sys
import time
import math
import os # <--- IMPORT THE OS MODULE

from qiskit import QuantumCircuit
from qiskit.circuit.library import RZZGate, RXGate, RYGate
from qiskit.compiler import transpile

from pyqrack import QrackSimulator

def factor_width(n):
    """
    Finds two integer factors (rows, cols) of n, aiming for factors close to sqrt(n).
    Simple approach: find the largest factor <= sqrt(n).
    Returns (rows, cols).
    """
    if n <= 0:
        raise ValueError("Number of qubits must be positive.")
    if n == 1:
        return 1, 1

    sqrt_n = int(math.sqrt(n))
    rows = 1
    # Find the largest factor <= sqrt(n)
    for i in range(sqrt_n, 0, -1):
        if n % i == 0:
            rows = i
            break # Found the largest factor <= sqrt(n)

    # The other factor
    cols = n // rows

    # Sanity check
    if rows * cols != n:
         # Fallback for prime numbers or unexpected issues
         rows = 1
         cols = n
         if rows * cols != n: # Should be impossible now
             raise ValueError(f"Could not properly factorize {n} into integer dimensions.")

    # Optional: Convention to have rows <= cols (doesn't affect physics)
    # if rows > cols:
    #     rows, cols = cols, rows

    print(f"Factoring {n} qubits into a {rows}x{cols} lattice.")
    return rows, cols # Returns rows, cols

def trotter_step(circ, qubits, lattice_shape, J, h, dt):
    """Applies one symmetric Trotter step for the 2D Ising model."""
    n_rows, n_cols = lattice_shape # Receives lattice_shape tuple

    # Note on Qiskit's RXGate: circ.rx(theta, q) implements exp(-i * theta/2 * X)
    # The Ising term exp(i * h * dt / 2 * X) requires theta = -h * dt.
    # This code uses theta = h * dt / 2 for each half-step,
    # resulting in exp(-i * (h*dt/4) * X) per application.
    # Corresponds to H = -h Sum X_i term evolution exp(-i*(-h*dt/2)*Sum X_i)
    rx_angle = h * dt / 2

    # First half of transverse field term (applied to all qubits)
    for q in qubits:
        circ.rx(rx_angle, q)

    # Layered RZZ interactions (simulate 2D nearest-neighbor coupling)
    # Note on Qiskit's RZZGate: circ.rzz(theta, q1, q2) implements exp(-i * theta/2 * Z�Z)
    # The Ising term exp(i * J * dt * Z�Z) requires theta = -2 * J * dt.
    # The code uses theta = 2 * J * dt, which implements exp(-i * J * dt * Z�Z).
    # Corresponds to H = -J Sum Z_i Z_j term evolution exp(-i*(-J*dt)*Sum Z_i Z_j)
    rzz_angle = 2 * J * dt

    def add_rzz_pairs(pairs):
        # Using append(gate, [q1, q2]) is slightly more explicit than circ.rzz
        # We still construct the RZZGate object here, but rely on transpile to decompose it later
        rzz_gate = RZZGate(rzz_angle)
        for q1, q2 in pairs:
            circ.append(rzz_gate, [q1, q2])

    # Layer 1: horizontal pairs (even rows, starting at col 0, step 2)
    # Handles pairs (c, c+1) for c = 0, 2, 4...
    horiz_pairs_even_c = [(r * n_cols + c, r * n_cols + (c + 1)) # No periodic boundary for last column here
                          for r in range(n_rows) for c in range(0, n_cols - 1, 2)]
    # Add periodic boundary condition pair if n_cols is even
    if n_cols > 1 and n_cols % 2 == 0:
         horiz_pairs_even_c.extend([(r * n_cols + (n_cols - 1), r * n_cols + 0) for r in range(n_rows)]) # (last, first)
    add_rzz_pairs(horiz_pairs_even_c)

    # Layer 2: horizontal pairs (even rows, starting at col 1, step 2)
    # Handles pairs (c, c+1) for c = 1, 3, 5...
    horiz_pairs_odd_c = [(r * n_cols + c, r * n_cols + (c + 1)) # No periodic boundary for last column here
                           for r in range(n_rows) for c in range(1, n_cols - 1, 2)]
    # Add periodic boundary condition pair if n_cols is odd and > 1
    if n_cols > 1 and n_cols % 2 != 0:
         horiz_pairs_odd_c.extend([(r * n_cols + (n_cols - 1), r * n_cols + 0) for r in range(n_rows)]) # (last, first)
    add_rzz_pairs(horiz_pairs_odd_c)

    # Layer 3: vertical pairs (even rows, starting at row 0, step 2)
    # Handles pairs (r, r+1) for r = 0, 2, 4...
    vert_pairs_even_r = [(r * n_cols + c, ((r + 1)) * n_cols + c) # No periodic boundary for last row here
                           for r in range(0, n_rows - 1, 2) for c in range(n_cols)]
    # Add periodic boundary condition pair if n_rows is even
    if n_rows > 1 and n_rows % 2 == 0:
         vert_pairs_even_r.extend([((n_rows - 1) * n_cols + c, 0 * n_cols + c) for c in range(n_cols)]) # (last, first)
    add_rzz_pairs(vert_pairs_even_r)

    # Layer 4: vertical pairs (odd rows, starting at row 1, step 2)
    # Handles pairs (r, r+1) for r = 1, 3, 5...
    vert_pairs_odd_r = [(r * n_cols + c, ((r + 1)) * n_cols + c) # No periodic boundary for last row here
                           for r in range(1, n_rows - 1, 2) for c in range(n_cols)]
    # Add periodic boundary condition pair if n_rows is odd and > 1
    if n_rows > 1 and n_rows % 2 != 0:
         vert_pairs_odd_r.extend([((n_rows - 1) * n_cols + c, 0 * n_cols + c) for c in range(n_cols)]) # (last, first)
    add_rzz_pairs(vert_pairs_odd_r)

    # Second half of transverse field term
    for q in qubits:
        circ.rx(rx_angle, q)

    # circ is modified in place, but returning it is conventional
    return circ

def main():
    depth = 1
    n_qubits = 56 # Default value
    if len(sys.argv) > 1:
        try:
            depth = int(sys.argv[1])
        except ValueError:
            print(f"Warning: Could not parse depth '{sys.argv[1]}'. Using default {depth}.")
    if len(sys.argv) > 2:
        try:
            n_qubits = int(sys.argv[2])
        except ValueError:
             print(f"Warning: Could not parse n_qubits '{sys.argv[2]}'. Using default {n_qubits}.")

    try:
        # Use the factor_width function to get lattice dimensions
        # Assigns return values to n_rows, n_cols
        n_rows, n_cols = factor_width(n_qubits)
    except ValueError as e:
        print(f"Error: {e}")
        return 1 # Exit with error code

    # --- Qrack Backend Configuration ---
    # Set the Qrack environment variable for Tensor Network threshold.
    # Change the value of 'qtensor_threshold' (as a string) to configure Qrack's behavior.
    # A value like "1" often forces BDD, while a higher value might enable QTensorNetwork.
    # Consult Qrack documentation for the precise meaning of this variable.
    qtensor_threshold = "1" # <-- CHANGE THIS VALUE AS NEEDED (must be a string)
    os.environ['QRACK_QTENSORNETWORK_THRESHOLD_QB'] = qtensor_threshold
    print(f"Set environment variable QRACK_QTENSORNETWORK_THRESHOLD_QB={os.environ['QRACK_QTENSORNETWORK_THRESHOLD_QB']}")


    # --- Ising Model Parameters ---
    J = -1.0 # Ferromagnetic coupling
    h = 2.0  # Transverse field strength
    dt = 0.25 # Trotter time step size

    # Initial state preparation angle
    # Prepare state |+> = H|0> (approx) if theta=pi/2, or other superposition
    initial_theta = -math.pi / 6 # Original value from script

    print(f"\nSimulating {n_qubits}-qubit ({n_rows}x{n_cols}) Ising model.")
    print(f"Parameters: J={J}, h={h}, dt={dt}, Trotter steps (depth)={depth}")
    print(f"Initial state: RY({initial_theta:.3f}) on all qubits.")

    # --- Circuit Construction ---
    qc = QuantumCircuit(n_qubits, name=f"Ising_{n_rows}x{n_cols}_d{depth}")

    # Initial state preparation
    for q in range(n_qubits):
        qc.ry(initial_theta, q) # Apply RY rotation to each qubit

    # Apply Trotter steps
    qubit_list = list(range(n_qubits))
    for step in range(depth):
        # Pass the tuple (n_rows, n_cols) as lattice_shape
        trotter_step(qc, qubit_list, (n_rows, n_cols), J, h, dt)
        # Optional: Add barrier for visualization/debugging
        # qc.barrier(label=f"Trotter {step+1}")

    # --- Transpilation ---
    # Define basis gates (can be adjusted based on simulator/hardware capabilities)
    # Removed 'rzz' as it's not directly supported by default Qrack backend implementations.
    # Transpile will decompose RZZ into simpler gates (CX, Rz, etc.).
    basis_gates = ["rz", "h", "x", "y", "z", "sx", "sxdg", "s", "sdg", "t", "tdg", "cx", "cy", "cz", "swap", "rx", "ry"]

    print("\nTranspiling circuit...")
    start_transpile = time.perf_counter()
    # Note: Transpiling might slightly alter the circuit if optimization_level > 0
    # For pure simulation, if Qrack handles the gates directly, transpilation might not be strictly needed
    # or could be done with optimization_level=0 just for basis translation.
    qc_transpiled = transpile(qc, basis_gates=basis_gates, optimization_level=0)
    transpile_time = time.perf_counter() - start_transpile
    print(f"Transpilation finished in {transpile_time:.4f} seconds.")
    # You will likely see an increase in circuit depth and operation count after transpilation now
    # print(f"Original depth: {qc.depth()}, Transpiled depth: {qc_transpiled.depth()}")
    # print(f"Original ops: {qc.count_ops()}, Transpiled ops: {qc_transpiled.count_ops()}")

    # --- Simulation ---
    print("\nInitializing QrackSimulator...")
    # QrackSimulator might read the QRACK_QTENSORNETWORK_THRESHOLD_QB environment variable
    # set earlier to determine which backend engine to use (e.g., BDD vs. Tensor Network).
    # isBinaryDecisionTree=True might explicitly request BDD, potentially overriding the env var.
    # Check PyQrack documentation for interaction details between flags and env vars.
    sim = QrackSimulator(n_qubits, isBinaryDecisionTree=True) # Note: isBinaryDecisionTree might take precedence

    print("Running simulation...")
    start_sim = time.perf_counter()
    # run_qiskit_circuit simulates the final statevector (when shots=0)
    sim.run_qiskit_circuit(qc_transpiled, shots=0)
    # m_all() performs a Z-basis measurement on the final statevector
    # For shots=0 run, it likely simulates a single perfect measurement outcome.
    result = sim.m_all()
    # get_unitary_fidelity() measures how accurately the simulator implemented the circuit matrix.
    fidelity = sim.get_unitary_fidelity()
    sim_time = time.perf_counter() - start_sim

    print(f"\n--- Results ---")
    print(f"Trotter steps: {depth}")
    print(f"Total simulation time: {sim_time:.4f} seconds")
    print(f"Conservative first-principles XEB estimate (Unitary Fidelity): {fidelity:.8f}")
    print(f"Simulated measurement outcome (m_all): {result}") # Result is usually a list of 0s and 1s

    # Optional: Clean up simulator resources if necessary (PyQrack might handle this automatically)
    # del sim

    return 0 # Success


if __name__ == '__main__':
    sys.exit(main())

